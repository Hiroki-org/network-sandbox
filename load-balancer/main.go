package loadbalancer
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"













































































































































































































































































































































































































































































































































































































}	return defaultVal	}		return val	if val := os.Getenv(key); val != "" {func getEnv(key, defaultVal string) string {}	}		log.Fatalf("Server error: %v", err)	if err := server.ListenAndServe(); err != http.ErrServerClosed {	log.Printf("Load Balancer starting on port %s (algorithm: %s)\n", port, algorithm)	}()		server.Shutdown(shutdownCtx)		defer shutdownCancel()		shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)		cancel()		log.Println("Shutting down load balancer...")		<-sigChan		signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)		sigChan := make(chan os.Signal, 1)	go func() {	// Graceful shutdown	}		Handler: handler,		Addr:    ":" + port,	server := &http.Server{	port := getEnv("PORT", "8080")	handler := corsMiddleware(mux)	mux.Handle("/metrics", promhttp.Handler())	// Metrics endpoint	})		json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})		w.Header().Set("Content-Type", "application/json")	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {	// Health endpoint	mux.HandleFunc("/ws", lb.handleWebSocket)	// WebSocket endpoint	})		}			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)		default:			json.NewEncoder(w).Encode(map[string]string{"algorithm": lb.algorithm})			w.Header().Set("Content-Type", "application/json")			lb.SetAlgorithm(body.Algorithm)			}				return				http.Error(w, "Invalid request", http.StatusBadRequest)			if err := json.NewDecoder(r.Body).Decode(&body); err != nil {			}				Algorithm string `json:"algorithm"`			var body struct {		case http.MethodPut:			json.NewEncoder(w).Encode(map[string]string{"algorithm": lb.algorithm})			w.Header().Set("Content-Type", "application/json")		case http.MethodGet:		switch r.Method {	mux.HandleFunc("/algorithm", func(w http.ResponseWriter, r *http.Request) {	// Algorithm endpoint	})		json.NewEncoder(w).Encode(lb.GetStatus())		w.Header().Set("Content-Type", "application/json")	mux.HandleFunc("/status", func(w http.ResponseWriter, r *http.Request) {	// Status endpoint	})		w.Write(respBody)		w.WriteHeader(statusCode)		w.Header().Set("Content-Type", "application/json")		go lb.BroadcastStatus()		// Broadcast update after processing		}			return			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})			w.WriteHeader(statusCode)			w.Header().Set("Content-Type", "application/json")		if err != nil {		respBody, statusCode, err := lb.ForwardRequest(task)		}			return			http.Error(w, "Invalid request body", http.StatusBadRequest)		if err := json.NewDecoder(r.Body).Decode(&task); err != nil {		var task TaskRequest		}			return			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)		if r.Method != http.MethodPost {	mux.HandleFunc("/task", func(w http.ResponseWriter, r *http.Request) {	// Task endpoint - forward to workers	mux := http.NewServeMux()	// HTTP handlers	go lb.StartHealthChecker(ctx)	// Start health checker	defer cancel()	ctx, cancel := context.WithCancel(context.Background())	// Create context for graceful shutdown	}		lb.AddWorker(w.name, w.url, w.color, w.weight)	for _, w := range workers {	}		{"python-worker-1", getEnv("WORKER_PYTHON_URL", "http://worker-python:8080"), "#22C55E", 1},		{"rust-worker-1", getEnv("WORKER_RUST_URL", "http://worker-rust:8080"), "#F97316", 1},		{"go-worker-1", getEnv("WORKER_GO_URL", "http://worker-go:8080"), "#3B82F6", 1},	}{		weight           int		name, url, color string	workers := []struct {	// Add workers from environment	lb := NewLoadBalancer(algorithm)	}		algorithm = "round-robin"	if algorithm == "" {	algorithm := os.Getenv("LB_ALGORITHM")	// Get algorithm from envfunc main() {}	})		next.ServeHTTP(w, r)				}			return			w.WriteHeader(http.StatusOK)		if r.Method == http.MethodOptions {				w.Header().Set("Access-Control-Allow-Headers", "Content-Type")		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, OPTIONS")		w.Header().Set("Access-Control-Allow-Origin", "*")	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {func corsMiddleware(next http.Handler) http.Handler {}	}		}			lb.wsMu.Unlock()			delete(lb.wsClients, client)			lb.wsMu.Lock()			client.Close()		if err := client.WriteJSON(status); err != nil {	for _, client := range clients {	status := lb.GetStatus()	lb.wsMu.RUnlock()	}		clients = append(clients, client)	for client := range lb.wsClients {	clients := make([]*websocket.Conn, 0, len(lb.wsClients))	lb.wsMu.RLock()func (lb *LoadBalancer) BroadcastStatus() {// BroadcastStatus sends current status to all WebSocket clients}	}		}			break		if err != nil {		_, _, err := conn.ReadMessage()	for {	// Keep connection alive and handle incoming messages	conn.WriteJSON(status)	status := lb.GetStatus()	// Send initial status	}()		lb.wsMu.Unlock()		delete(lb.wsClients, conn)		lb.wsMu.Lock()	defer func() {	lb.wsMu.Unlock()	lb.wsClients[conn] = true	lb.wsMu.Lock()	defer conn.Close()	}		return		log.Printf("WebSocket upgrade error: %v\n", err)	if err != nil {	conn, err := upgrader.Upgrade(w, r, nil)func (lb *LoadBalancer) handleWebSocket(w http.ResponseWriter, r *http.Request) {// WebSocket handler for real-time updates}	log.Printf("Algorithm changed to: %s\n", algo)	lb.algorithm = algo	defer lb.mu.Unlock()	lb.mu.Lock()func (lb *LoadBalancer) SetAlgorithm(algo string) {// SetAlgorithm changes the load balancing algorithm}	}		"workers":   workersStatus,		"algorithm": lb.algorithm,	return map[string]interface{}{	}		w.mu.RUnlock()		}			"consecFailures": w.ConsecFailures,			"circuitOpen":    w.CircuitOpen,			"failedRequests": atomic.LoadInt64(&w.FailedRequests),			"totalRequests":  atomic.LoadInt64(&w.TotalRequests),			"weight":         w.Weight,			"currentLoad":    atomic.LoadInt32(&w.CurrentLoad),			"healthy":        w.Healthy,			"color":          w.Color,			"url":            w.URL,			"name":           w.Name,		workersStatus[i] = map[string]interface{}{		w.mu.RLock()	for i, w := range lb.workers {	workersStatus := make([]map[string]interface{}, len(lb.workers))	defer lb.mu.RUnlock()	lb.mu.RLock()func (lb *LoadBalancer) GetStatus() map[string]interface{} {// GetStatus returns current status of all workers}	}		}			lb.BroadcastStatus()			lb.HealthCheck()		case <-ticker.C:			return		case <-ctx.Done():		select {	for {	defer ticker.Stop()	ticker := time.NewTicker(lb.healthCheckInterval)func (lb *LoadBalancer) StartHealthChecker(ctx context.Context) {// StartHealthChecker starts the periodic health check}	}		}(worker)			activeConnections.WithLabelValues(w.Name).Set(float64(w.CurrentLoad))						}				workerHealth.WithLabelValues(w.Name).Set(0)			} else {				workerHealth.WithLabelValues(w.Name).Set(1)			if w.Healthy {						w.CurrentLoad = health.CurrentLoad			w.Healthy = health.Status != "unhealthy"			}				return				workerHealth.WithLabelValues(w.Name).Set(0)				w.Healthy = false			if err := json.NewDecoder(resp.Body).Decode(&health); err != nil {			var health HealthResponse			}				return				workerHealth.WithLabelValues(w.Name).Set(0)				w.Healthy = false			if resp.StatusCode != http.StatusOK {			defer resp.Body.Close()			}				return				log.Printf("Health check failed for %s: %v\n", w.Name, err)				workerHealth.WithLabelValues(w.Name).Set(0)				w.Healthy = false			if err != nil {						w.LastHealthCheck = time.Now()						defer w.mu.Unlock()			w.mu.Lock()						resp, err := client.Get(w.URL + "/health")		go func(w *Worker) {	for _, worker := range workers {	client := &http.Client{Timeout: 5 * time.Second}	lb.mu.RUnlock()	workers := lb.workers	lb.mu.RLock()func (lb *LoadBalancer) HealthCheck() {// HealthCheck performs health checks on all workers}	worker.ConsecFailures = 0	defer worker.mu.Unlock()	worker.mu.Lock()func (lb *LoadBalancer) recordSuccess(worker *Worker) {}	}		}(worker)			log.Printf("Circuit CLOSED for worker %s (recovery attempted)\n", w.Name)			w.mu.Unlock()			w.ConsecFailures = 0			w.CircuitOpen = false			w.mu.Lock()			time.Sleep(lb.circuitRecovery)		go func(w *Worker) {		// Schedule circuit recovery				workerHealth.WithLabelValues(worker.Name).Set(0)		log.Printf("Circuit OPEN for worker %s (consecutive failures: %d)\n", worker.Name, worker.ConsecFailures)		worker.CircuitOpen = true	if worker.ConsecFailures >= lb.circuitThreshold {	worker.ConsecFailures++		defer worker.mu.Unlock()	worker.mu.Lock()func (lb *LoadBalancer) recordFailure(worker *Worker) {}	return respBody, resp.StatusCode, nil	}		requestsTotal.WithLabelValues(worker.Name, "success").Inc()		lb.recordSuccess(worker)	} else {		atomic.AddInt64(&worker.FailedRequests, 1)		requestsTotal.WithLabelValues(worker.Name, "failed").Inc()		lb.recordFailure(worker)	if resp.StatusCode >= 500 {	atomic.AddInt64(&worker.TotalRequests, 1)	}		return nil, http.StatusBadGateway, err		requestsTotal.WithLabelValues(worker.Name, "error").Inc()		lb.recordFailure(worker)	if err != nil {	respBody, err := io.ReadAll(resp.Body)	defer resp.Body.Close()	}		return nil, http.StatusBadGateway, err		requestsTotal.WithLabelValues(worker.Name, "error").Inc()		lb.recordFailure(worker)	if err != nil {	requestDuration.WithLabelValues(worker.Name).Observe(float64(duration))	duration := time.Since(start).Milliseconds()		resp, err := client.Post(worker.URL+"/task", "application/json", bytes.NewReader(body))	client := &http.Client{Timeout: 30 * time.Second}	}		return nil, http.StatusBadRequest, err	if err != nil {	body, err := json.Marshal(task)		start := time.Now()	}()		activeConnections.WithLabelValues(worker.Name).Set(float64(atomic.LoadInt32(&worker.CurrentLoad)))		atomic.AddInt32(&worker.CurrentLoad, -1)	defer func() {	activeConnections.WithLabelValues(worker.Name).Set(float64(atomic.LoadInt32(&worker.CurrentLoad)))	atomic.AddInt32(&worker.CurrentLoad, 1)	}		return nil, http.StatusServiceUnavailable, fmt.Errorf("no healthy workers available")	if worker == nil {	worker := lb.SelectWorker()func (lb *LoadBalancer) ForwardRequest(task TaskRequest) ([]byte, int, error) {// ForwardRequest forwards request to selected worker}	return workers[time.Now().UnixNano()%int64(len(workers))]func (lb *LoadBalancer) random(workers []*Worker) *Worker {}	return workers[0]	}		}			return w		if target < cumulative {		cumulative += w.Weight	for _, w := range workers {	cumulative := 0		target := counter % totalWeight	counter := int(atomic.AddUint64(&lb.roundRobinCounter, 1))		}		totalWeight += w.Weight	for _, w := range workers {	totalWeight := 0func (lb *LoadBalancer) weighted(workers []*Worker) *Worker {}	return workers[0]	})		return atomic.LoadInt32(&workers[i].CurrentLoad) < atomic.LoadInt32(&workers[j].CurrentLoad)	sort.Slice(workers, func(i, j int) bool {func (lb *LoadBalancer) leastConnections(workers []*Worker) *Worker {}	return workers[(counter-1)%uint64(len(workers))]	counter := atomic.AddUint64(&lb.roundRobinCounter, 1)func (lb *LoadBalancer) roundRobin(workers []*Worker) *Worker {}	}		return lb.roundRobin(healthy)	default: // round-robin		return lb.random(healthy)	case "random":		return lb.weighted(healthy)	case "weighted":		return lb.leastConnections(healthy)	case "least-connections":	switch lb.algorithm {	}		return nil	if len(healthy) == 0 {	healthy := lb.getHealthyWorkers()func (lb *LoadBalancer) SelectWorker() *Worker {// SelectWorker selects a worker based on the configured algorithm}	return healthy	}		w.mu.RUnlock()		}			healthy = append(healthy, w)		if w.Healthy && !w.CircuitOpen {		w.mu.RLock()	for _, w := range lb.workers {	healthy := make([]*Worker, 0)		defer lb.mu.RUnlock()	lb.mu.RLock()func (lb *LoadBalancer) getHealthyWorkers() []*Worker {// getHealthyWorkers returns list of healthy workers}	log.Printf("Added worker: %s at %s\n", name, url)	workerHealth.WithLabelValues(name).Set(1)	lb.workers = append(lb.workers, worker)	}		Weight:  weight,		Healthy: true,		Color:   color,		URL:     url,		Name:    name,	worker := &Worker{		defer lb.mu.Unlock()	lb.mu.Lock()func (lb *LoadBalancer) AddWorker(name, url, color string, weight int) {// AddWorker adds a new worker to the pool}	}		wsClients:           make(map[*websocket.Conn]bool),		circuitRecovery:     30 * time.Second,		circuitThreshold:    5,		healthCheckInterval: 5 * time.Second,		algorithm:           algorithm,		workers:             make([]*Worker, 0),	return &LoadBalancer{func NewLoadBalancer(algorithm string) *LoadBalancer {// NewLoadBalancer creates a new load balancer instance}	prometheus.MustRegister(activeConnections)	prometheus.MustRegister(workerHealth)	prometheus.MustRegister(requestDuration)	prometheus.MustRegister(requestsTotal)func init() {}	},		return true	CheckOrigin: func(r *http.Request) bool {var upgrader = websocket.Upgrader{)	)		[]string{"worker"},		},			Help: "Current active connections per worker",			Name: "lb_worker_active_connections",		prometheus.GaugeOpts{	activeConnections = prometheus.NewGaugeVec(	)		[]string{"worker"},		},			Help: "Worker health status (1=healthy, 0=unhealthy)",			Name: "lb_worker_health",		prometheus.GaugeOpts{	workerHealth = prometheus.NewGaugeVec(	)		[]string{"worker"},		},			Buckets: prometheus.ExponentialBuckets(1, 2, 12),			Help:    "Request duration in milliseconds",			Name:    "lb_request_duration_ms",		prometheus.HistogramOpts{	requestDuration = prometheus.NewHistogramVec(	)		[]string{"worker", "status"},		},			Help: "Total number of requests processed by load balancer",			Name: "lb_requests_total",		prometheus.CounterOpts{	requestsTotal = prometheus.NewCounterVec(var (// Metrics}	wsMu              sync.RWMutex	wsClients         map[*websocket.Conn]bool	mu                sync.RWMutex	circuitRecovery   time.Duration	circuitThreshold  int	healthCheckInterval time.Duration	roundRobinCounter uint64	algorithm         string	workers           []*Workertype LoadBalancer struct {// LoadBalancer manages workers and request distribution}	Weight float64 `json:"weight"`	ID     string  `json:"id"`type TaskRequest struct {// TaskRequest represents incoming task}	QueueDepth  int    `json:"queueDepth"`	CurrentLoad int32  `json:"currentLoad"`	Status      string `json:"status"`type HealthResponse struct {// HealthResponse from worker}	mu              sync.RWMutex	LastHealthCheck time.Time `json:"lastHealthCheck"`	ConsecFailures  int     `json:"consecFailures"`	CircuitOpen     bool    `json:"circuitOpen"`	FailedRequests  int64   `json:"failedRequests"`	TotalRequests   int64   `json:"totalRequests"`	Weight          int     `json:"weight"`	CurrentLoad     int32   `json:"currentLoad"`	Healthy         bool    `json:"healthy"`	Color           string  `json:"color"`	URL             string  `json:"url"`	Name            string  `json:"name"`type Worker struct {// Worker represents a backend worker service)	"github.com/prometheus/client_golang/prometheus/promhttp"	"github.com/prometheus/client_golang/prometheus"	"github.com/gorilla/websocket"	"time"	"syscall"	"sync/atomic"	"sync"	"sort"	"os/signal"	"os"